---
title: Tips para novat@s
---

# Tips para novat@s

### Sobre lenguajes de programación

En programación competitiva el lenguaje más utilizado por lejos es C++ (y dentro de C++ generalmente se usa de C++11 para arriba). En segundo lugar se encuentra Java. [Y hace muy poco se comenzó a utilizar también Python](https://www.quora.com/Can-Python-be-used-in-ACM-ICPC). Sin embargo, lamentablemente la mayoría de los jueces online (los servidores que tienen los enunciados de los problemas y ejecutan los códigos enviados por la gente) están calibrados generalmente para aceptar soluciones en C++, y a veces pasa que las soluciones en Python fallan con el famoso [Time Limit Exceeded (TLE)](https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/), debido a que Python por ser un lenguaje interpretado se ejecuta más lento que lenguajes compilados a código de máquina como C++. Además, la mayoría de los códigos de ejemplo disponibles en internet para progcomp están en C++ o quizá Java. Por este motivo, el consejo típico es aprender C++. Si te motivas a seguir este consejo, en la [sección para aprender C++](resources/cpp) puedes encontrar bastante material para aprender. Dicho esto, que esto por favor no se malinterprete como que usar C++ es una obligación. No, no. Si lo deseas, puedes usar Python, no hay ningún problema con eso. De hecho en muchos problemas las restricciones de tiempo son suficientemente holgadas y usar Python es perfectamente válido.

El objetivo de este comentario es simplemente hacerte conciente de que al usar Python existe cierto riesgo de TLE por jueces "pesados" con restricciones de tiempo muy estrictas, y también que C++ es por lejos el lenguaje más popular en programación competitiva. Si decides aprender C++, nuestro consejo es que vayas aprendiendo poco a poco, sin estresarte. Por ejemplo puedes ir intercalando entre C++ y Python. O puedes programar una solución en Python y después traducirla a C++, etc. Además siempre estaremos subiendo ejemplos de soluciones en C++, y tanto el profesor como el ayudante estaremos disponibles para que nos hagas todas las consultas que necesites.

### Sobre restricciones de tiempo y memoria en programación competitiva

- En la ICPC y en la mayoría de los jueces online de entrenamiento los problemas tienen límites de tiempo (ej. 3 segundos) y memoria (ej. 256 MB). Esto significa que soluciones muy lentas o soluciones que requieren anotar demasiadas cosas **no funcionarán**.
- En C++ pueden hacerse un poco más de **$10^8$ operaciones baratas por segundo** (una estimación bien al ojo por experiencia con diferentes jueces online). Por lo tanto, si les dan $K$ segundos de tiempo límite, a lo más podrán hacer un poco más de $K \cdot 10^8$ operaciones baratas. Tengan esto muy presente.
- **MUY IMPORTANTE**: **ANTES DE TOCAR EL TECLADO, ANTES DE ESCRIBIR LA PRIMERA LÍNEA DE CÓDIGO**, es sumamente importante estimar cuánto se va a demorar la estrategia/algoritmo que quiero programar. Nadie quiere desperdiciar su tiempo programando una solución que después es muy lenta y nos da TLE (Time Limit Exceeded). Es por esto que **siempre deben estimar la [complejidad computacional](https://en.wikipedia.org/wiki/Time_complexity)** de su algoritmo y **evaluarla en el caso borde más grande** (peor caso). Por ejemplo, si un problema depende de $N$ donde $1 \leq N \leq 10^5$ y mi algoritmo es cuadrático (complejidad $= \mathcal{O}(N^2)$), entonces en el peor caso haré $(10^5)^2 = 10^{10}$ operaciones, y por ende según el punto anterior necesitaría **100 segundos** para correrlo. En cambio, si mi algoritmo tiene complejidad $\mathcal{O}(N\cdot\log(N))$ entonces en el peor caso sólo haré $10^5 \cdot \log(10^5) = 1.7 \cdot 10^6$ operaciones (aprox.), y por ende sólo necesitaría **$0.017$ segundos** (la nada misma) para correrlo. Entonces, si mi problema tiene un tiempo máximo de ejecución de 2 segundos, ¿qué algoritmo va a funcionar? Claramente el segundo.
- Si van a usar mucha memoria, preocúpense de **no pasarse del límite de memoria permitido**. Por ejemplo si les dan 256MB de memoria, en bytes eso es $256 \cdot 1024 \cdot 1024 = 268435456$ bytes, un int32 ocupa 4 bytes, así que como máximo podrían crear un arreglo de int32 de largo $67108864 = 6.7 \cdot 10^7$ aprox (o la mitad si usan un int64, un double, etc.). También podría acabárseles la memoria si hacen demasiadas llamadas recursivas [[1](https://codeforces.com/blog/entry/47003), [2](https://stackoverflow.com/a/11777585/2801404)].
